// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"github.com/google/uuid"
	"sync"
	"time"
)

// Ensure, that OAuth2RepositoryMock does implement OAuth2Repository.
// If this is not the case, regenerate this file with moq.
var _ OAuth2Repository = &OAuth2RepositoryMock{}

// OAuth2RepositoryMock is a mock implementation of OAuth2Repository.
//
//	func TestSomethingThatUsesOAuth2Repository(t *testing.T) {
//
//		// make and configure a mocked OAuth2Repository
//		mockedOAuth2Repository := &OAuth2RepositoryMock{
//			CreateUserFunc: func(u *User) error {
//				panic("mock out the CreateUser method")
//			},
//			ExistsUserByEmailFunc: func(email string) (bool, error) {
//				panic("mock out the ExistsUserByEmail method")
//			},
//			FindClientByClientIDFunc: func(clientID string) (Client, error) {
//				panic("mock out the FindClientByClientID method")
//			},
//			FindTokenFunc: func(accessToken string) (Token, error) {
//				panic("mock out the FindToken method")
//			},
//			FindUserFunc: func(id uuid.UUID) (User, error) {
//				panic("mock out the FindUser method")
//			},
//			FindUserByEmailFunc: func(email string) (User, error) {
//				panic("mock out the FindUserByEmail method")
//			},
//			FindValidOAuth2CodeFunc: func(code string, expiresAt time.Time) (Code, error) {
//				panic("mock out the FindValidOAuth2Code method")
//			},
//			FindValidRefreshTokenFunc: func(refreshToken string, expiresAt time.Time) (RefreshToken, error) {
//				panic("mock out the FindValidRefreshToken method")
//			},
//			RegisterOAuth2CodeFunc: func(c *Code) error {
//				panic("mock out the RegisterOAuth2Code method")
//			},
//			RegisterRefreshTokenFunc: func(t *RefreshToken) error {
//				panic("mock out the RegisterRefreshToken method")
//			},
//			RegisterTokenFunc: func(t *Token) error {
//				panic("mock out the RegisterToken method")
//			},
//			RevokeCodeFunc: func(code string) error {
//				panic("mock out the RevokeCode method")
//			},
//			RevokeRefreshTokenFunc: func(refreshToken string) error {
//				panic("mock out the RevokeRefreshToken method")
//			},
//			RevokeTokenFunc: func(accessToken string) error {
//				panic("mock out the RevokeToken method")
//			},
//		}
//
//		// use mockedOAuth2Repository in code that requires OAuth2Repository
//		// and then make assertions.
//
//	}
type OAuth2RepositoryMock struct {
	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(u *User) error

	// ExistsUserByEmailFunc mocks the ExistsUserByEmail method.
	ExistsUserByEmailFunc func(email string) (bool, error)

	// FindClientByClientIDFunc mocks the FindClientByClientID method.
	FindClientByClientIDFunc func(clientID string) (Client, error)

	// FindTokenFunc mocks the FindToken method.
	FindTokenFunc func(accessToken string) (Token, error)

	// FindUserFunc mocks the FindUser method.
	FindUserFunc func(id uuid.UUID) (User, error)

	// FindUserByEmailFunc mocks the FindUserByEmail method.
	FindUserByEmailFunc func(email string) (User, error)

	// FindValidOAuth2CodeFunc mocks the FindValidOAuth2Code method.
	FindValidOAuth2CodeFunc func(code string, expiresAt time.Time) (Code, error)

	// FindValidRefreshTokenFunc mocks the FindValidRefreshToken method.
	FindValidRefreshTokenFunc func(refreshToken string, expiresAt time.Time) (RefreshToken, error)

	// RegisterOAuth2CodeFunc mocks the RegisterOAuth2Code method.
	RegisterOAuth2CodeFunc func(c *Code) error

	// RegisterRefreshTokenFunc mocks the RegisterRefreshToken method.
	RegisterRefreshTokenFunc func(t *RefreshToken) error

	// RegisterTokenFunc mocks the RegisterToken method.
	RegisterTokenFunc func(t *Token) error

	// RevokeCodeFunc mocks the RevokeCode method.
	RevokeCodeFunc func(code string) error

	// RevokeRefreshTokenFunc mocks the RevokeRefreshToken method.
	RevokeRefreshTokenFunc func(refreshToken string) error

	// RevokeTokenFunc mocks the RevokeToken method.
	RevokeTokenFunc func(accessToken string) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// U is the u argument value.
			U *User
		}
		// ExistsUserByEmail holds details about calls to the ExistsUserByEmail method.
		ExistsUserByEmail []struct {
			// Email is the email argument value.
			Email string
		}
		// FindClientByClientID holds details about calls to the FindClientByClientID method.
		FindClientByClientID []struct {
			// ClientID is the clientID argument value.
			ClientID string
		}
		// FindToken holds details about calls to the FindToken method.
		FindToken []struct {
			// AccessToken is the accessToken argument value.
			AccessToken string
		}
		// FindUser holds details about calls to the FindUser method.
		FindUser []struct {
			// ID is the id argument value.
			ID uuid.UUID
		}
		// FindUserByEmail holds details about calls to the FindUserByEmail method.
		FindUserByEmail []struct {
			// Email is the email argument value.
			Email string
		}
		// FindValidOAuth2Code holds details about calls to the FindValidOAuth2Code method.
		FindValidOAuth2Code []struct {
			// Code is the code argument value.
			Code string
			// ExpiresAt is the expiresAt argument value.
			ExpiresAt time.Time
		}
		// FindValidRefreshToken holds details about calls to the FindValidRefreshToken method.
		FindValidRefreshToken []struct {
			// RefreshToken is the refreshToken argument value.
			RefreshToken string
			// ExpiresAt is the expiresAt argument value.
			ExpiresAt time.Time
		}
		// RegisterOAuth2Code holds details about calls to the RegisterOAuth2Code method.
		RegisterOAuth2Code []struct {
			// C is the c argument value.
			C *Code
		}
		// RegisterRefreshToken holds details about calls to the RegisterRefreshToken method.
		RegisterRefreshToken []struct {
			// T is the t argument value.
			T *RefreshToken
		}
		// RegisterToken holds details about calls to the RegisterToken method.
		RegisterToken []struct {
			// T is the t argument value.
			T *Token
		}
		// RevokeCode holds details about calls to the RevokeCode method.
		RevokeCode []struct {
			// Code is the code argument value.
			Code string
		}
		// RevokeRefreshToken holds details about calls to the RevokeRefreshToken method.
		RevokeRefreshToken []struct {
			// RefreshToken is the refreshToken argument value.
			RefreshToken string
		}
		// RevokeToken holds details about calls to the RevokeToken method.
		RevokeToken []struct {
			// AccessToken is the accessToken argument value.
			AccessToken string
		}
	}
	lockCreateUser            sync.RWMutex
	lockExistsUserByEmail     sync.RWMutex
	lockFindClientByClientID  sync.RWMutex
	lockFindToken             sync.RWMutex
	lockFindUser              sync.RWMutex
	lockFindUserByEmail       sync.RWMutex
	lockFindValidOAuth2Code   sync.RWMutex
	lockFindValidRefreshToken sync.RWMutex
	lockRegisterOAuth2Code    sync.RWMutex
	lockRegisterRefreshToken  sync.RWMutex
	lockRegisterToken         sync.RWMutex
	lockRevokeCode            sync.RWMutex
	lockRevokeRefreshToken    sync.RWMutex
	lockRevokeToken           sync.RWMutex
}

// CreateUser calls CreateUserFunc.
func (mock *OAuth2RepositoryMock) CreateUser(u *User) error {
	if mock.CreateUserFunc == nil {
		panic("OAuth2RepositoryMock.CreateUserFunc: method is nil but OAuth2Repository.CreateUser was just called")
	}
	callInfo := struct {
		U *User
	}{
		U: u,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(u)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedOAuth2Repository.CreateUserCalls())
func (mock *OAuth2RepositoryMock) CreateUserCalls() []struct {
	U *User
} {
	var calls []struct {
		U *User
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// ExistsUserByEmail calls ExistsUserByEmailFunc.
func (mock *OAuth2RepositoryMock) ExistsUserByEmail(email string) (bool, error) {
	if mock.ExistsUserByEmailFunc == nil {
		panic("OAuth2RepositoryMock.ExistsUserByEmailFunc: method is nil but OAuth2Repository.ExistsUserByEmail was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockExistsUserByEmail.Lock()
	mock.calls.ExistsUserByEmail = append(mock.calls.ExistsUserByEmail, callInfo)
	mock.lockExistsUserByEmail.Unlock()
	return mock.ExistsUserByEmailFunc(email)
}

// ExistsUserByEmailCalls gets all the calls that were made to ExistsUserByEmail.
// Check the length with:
//
//	len(mockedOAuth2Repository.ExistsUserByEmailCalls())
func (mock *OAuth2RepositoryMock) ExistsUserByEmailCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockExistsUserByEmail.RLock()
	calls = mock.calls.ExistsUserByEmail
	mock.lockExistsUserByEmail.RUnlock()
	return calls
}

// FindClientByClientID calls FindClientByClientIDFunc.
func (mock *OAuth2RepositoryMock) FindClientByClientID(clientID string) (Client, error) {
	if mock.FindClientByClientIDFunc == nil {
		panic("OAuth2RepositoryMock.FindClientByClientIDFunc: method is nil but OAuth2Repository.FindClientByClientID was just called")
	}
	callInfo := struct {
		ClientID string
	}{
		ClientID: clientID,
	}
	mock.lockFindClientByClientID.Lock()
	mock.calls.FindClientByClientID = append(mock.calls.FindClientByClientID, callInfo)
	mock.lockFindClientByClientID.Unlock()
	return mock.FindClientByClientIDFunc(clientID)
}

// FindClientByClientIDCalls gets all the calls that were made to FindClientByClientID.
// Check the length with:
//
//	len(mockedOAuth2Repository.FindClientByClientIDCalls())
func (mock *OAuth2RepositoryMock) FindClientByClientIDCalls() []struct {
	ClientID string
} {
	var calls []struct {
		ClientID string
	}
	mock.lockFindClientByClientID.RLock()
	calls = mock.calls.FindClientByClientID
	mock.lockFindClientByClientID.RUnlock()
	return calls
}

// FindToken calls FindTokenFunc.
func (mock *OAuth2RepositoryMock) FindToken(accessToken string) (Token, error) {
	if mock.FindTokenFunc == nil {
		panic("OAuth2RepositoryMock.FindTokenFunc: method is nil but OAuth2Repository.FindToken was just called")
	}
	callInfo := struct {
		AccessToken string
	}{
		AccessToken: accessToken,
	}
	mock.lockFindToken.Lock()
	mock.calls.FindToken = append(mock.calls.FindToken, callInfo)
	mock.lockFindToken.Unlock()
	return mock.FindTokenFunc(accessToken)
}

// FindTokenCalls gets all the calls that were made to FindToken.
// Check the length with:
//
//	len(mockedOAuth2Repository.FindTokenCalls())
func (mock *OAuth2RepositoryMock) FindTokenCalls() []struct {
	AccessToken string
} {
	var calls []struct {
		AccessToken string
	}
	mock.lockFindToken.RLock()
	calls = mock.calls.FindToken
	mock.lockFindToken.RUnlock()
	return calls
}

// FindUser calls FindUserFunc.
func (mock *OAuth2RepositoryMock) FindUser(id uuid.UUID) (User, error) {
	if mock.FindUserFunc == nil {
		panic("OAuth2RepositoryMock.FindUserFunc: method is nil but OAuth2Repository.FindUser was just called")
	}
	callInfo := struct {
		ID uuid.UUID
	}{
		ID: id,
	}
	mock.lockFindUser.Lock()
	mock.calls.FindUser = append(mock.calls.FindUser, callInfo)
	mock.lockFindUser.Unlock()
	return mock.FindUserFunc(id)
}

// FindUserCalls gets all the calls that were made to FindUser.
// Check the length with:
//
//	len(mockedOAuth2Repository.FindUserCalls())
func (mock *OAuth2RepositoryMock) FindUserCalls() []struct {
	ID uuid.UUID
} {
	var calls []struct {
		ID uuid.UUID
	}
	mock.lockFindUser.RLock()
	calls = mock.calls.FindUser
	mock.lockFindUser.RUnlock()
	return calls
}

// FindUserByEmail calls FindUserByEmailFunc.
func (mock *OAuth2RepositoryMock) FindUserByEmail(email string) (User, error) {
	if mock.FindUserByEmailFunc == nil {
		panic("OAuth2RepositoryMock.FindUserByEmailFunc: method is nil but OAuth2Repository.FindUserByEmail was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockFindUserByEmail.Lock()
	mock.calls.FindUserByEmail = append(mock.calls.FindUserByEmail, callInfo)
	mock.lockFindUserByEmail.Unlock()
	return mock.FindUserByEmailFunc(email)
}

// FindUserByEmailCalls gets all the calls that were made to FindUserByEmail.
// Check the length with:
//
//	len(mockedOAuth2Repository.FindUserByEmailCalls())
func (mock *OAuth2RepositoryMock) FindUserByEmailCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockFindUserByEmail.RLock()
	calls = mock.calls.FindUserByEmail
	mock.lockFindUserByEmail.RUnlock()
	return calls
}

// FindValidOAuth2Code calls FindValidOAuth2CodeFunc.
func (mock *OAuth2RepositoryMock) FindValidOAuth2Code(code string, expiresAt time.Time) (Code, error) {
	if mock.FindValidOAuth2CodeFunc == nil {
		panic("OAuth2RepositoryMock.FindValidOAuth2CodeFunc: method is nil but OAuth2Repository.FindValidOAuth2Code was just called")
	}
	callInfo := struct {
		Code      string
		ExpiresAt time.Time
	}{
		Code:      code,
		ExpiresAt: expiresAt,
	}
	mock.lockFindValidOAuth2Code.Lock()
	mock.calls.FindValidOAuth2Code = append(mock.calls.FindValidOAuth2Code, callInfo)
	mock.lockFindValidOAuth2Code.Unlock()
	return mock.FindValidOAuth2CodeFunc(code, expiresAt)
}

// FindValidOAuth2CodeCalls gets all the calls that were made to FindValidOAuth2Code.
// Check the length with:
//
//	len(mockedOAuth2Repository.FindValidOAuth2CodeCalls())
func (mock *OAuth2RepositoryMock) FindValidOAuth2CodeCalls() []struct {
	Code      string
	ExpiresAt time.Time
} {
	var calls []struct {
		Code      string
		ExpiresAt time.Time
	}
	mock.lockFindValidOAuth2Code.RLock()
	calls = mock.calls.FindValidOAuth2Code
	mock.lockFindValidOAuth2Code.RUnlock()
	return calls
}

// FindValidRefreshToken calls FindValidRefreshTokenFunc.
func (mock *OAuth2RepositoryMock) FindValidRefreshToken(refreshToken string, expiresAt time.Time) (RefreshToken, error) {
	if mock.FindValidRefreshTokenFunc == nil {
		panic("OAuth2RepositoryMock.FindValidRefreshTokenFunc: method is nil but OAuth2Repository.FindValidRefreshToken was just called")
	}
	callInfo := struct {
		RefreshToken string
		ExpiresAt    time.Time
	}{
		RefreshToken: refreshToken,
		ExpiresAt:    expiresAt,
	}
	mock.lockFindValidRefreshToken.Lock()
	mock.calls.FindValidRefreshToken = append(mock.calls.FindValidRefreshToken, callInfo)
	mock.lockFindValidRefreshToken.Unlock()
	return mock.FindValidRefreshTokenFunc(refreshToken, expiresAt)
}

// FindValidRefreshTokenCalls gets all the calls that were made to FindValidRefreshToken.
// Check the length with:
//
//	len(mockedOAuth2Repository.FindValidRefreshTokenCalls())
func (mock *OAuth2RepositoryMock) FindValidRefreshTokenCalls() []struct {
	RefreshToken string
	ExpiresAt    time.Time
} {
	var calls []struct {
		RefreshToken string
		ExpiresAt    time.Time
	}
	mock.lockFindValidRefreshToken.RLock()
	calls = mock.calls.FindValidRefreshToken
	mock.lockFindValidRefreshToken.RUnlock()
	return calls
}

// RegisterOAuth2Code calls RegisterOAuth2CodeFunc.
func (mock *OAuth2RepositoryMock) RegisterOAuth2Code(c *Code) error {
	if mock.RegisterOAuth2CodeFunc == nil {
		panic("OAuth2RepositoryMock.RegisterOAuth2CodeFunc: method is nil but OAuth2Repository.RegisterOAuth2Code was just called")
	}
	callInfo := struct {
		C *Code
	}{
		C: c,
	}
	mock.lockRegisterOAuth2Code.Lock()
	mock.calls.RegisterOAuth2Code = append(mock.calls.RegisterOAuth2Code, callInfo)
	mock.lockRegisterOAuth2Code.Unlock()
	return mock.RegisterOAuth2CodeFunc(c)
}

// RegisterOAuth2CodeCalls gets all the calls that were made to RegisterOAuth2Code.
// Check the length with:
//
//	len(mockedOAuth2Repository.RegisterOAuth2CodeCalls())
func (mock *OAuth2RepositoryMock) RegisterOAuth2CodeCalls() []struct {
	C *Code
} {
	var calls []struct {
		C *Code
	}
	mock.lockRegisterOAuth2Code.RLock()
	calls = mock.calls.RegisterOAuth2Code
	mock.lockRegisterOAuth2Code.RUnlock()
	return calls
}

// RegisterRefreshToken calls RegisterRefreshTokenFunc.
func (mock *OAuth2RepositoryMock) RegisterRefreshToken(t *RefreshToken) error {
	if mock.RegisterRefreshTokenFunc == nil {
		panic("OAuth2RepositoryMock.RegisterRefreshTokenFunc: method is nil but OAuth2Repository.RegisterRefreshToken was just called")
	}
	callInfo := struct {
		T *RefreshToken
	}{
		T: t,
	}
	mock.lockRegisterRefreshToken.Lock()
	mock.calls.RegisterRefreshToken = append(mock.calls.RegisterRefreshToken, callInfo)
	mock.lockRegisterRefreshToken.Unlock()
	return mock.RegisterRefreshTokenFunc(t)
}

// RegisterRefreshTokenCalls gets all the calls that were made to RegisterRefreshToken.
// Check the length with:
//
//	len(mockedOAuth2Repository.RegisterRefreshTokenCalls())
func (mock *OAuth2RepositoryMock) RegisterRefreshTokenCalls() []struct {
	T *RefreshToken
} {
	var calls []struct {
		T *RefreshToken
	}
	mock.lockRegisterRefreshToken.RLock()
	calls = mock.calls.RegisterRefreshToken
	mock.lockRegisterRefreshToken.RUnlock()
	return calls
}

// RegisterToken calls RegisterTokenFunc.
func (mock *OAuth2RepositoryMock) RegisterToken(t *Token) error {
	if mock.RegisterTokenFunc == nil {
		panic("OAuth2RepositoryMock.RegisterTokenFunc: method is nil but OAuth2Repository.RegisterToken was just called")
	}
	callInfo := struct {
		T *Token
	}{
		T: t,
	}
	mock.lockRegisterToken.Lock()
	mock.calls.RegisterToken = append(mock.calls.RegisterToken, callInfo)
	mock.lockRegisterToken.Unlock()
	return mock.RegisterTokenFunc(t)
}

// RegisterTokenCalls gets all the calls that were made to RegisterToken.
// Check the length with:
//
//	len(mockedOAuth2Repository.RegisterTokenCalls())
func (mock *OAuth2RepositoryMock) RegisterTokenCalls() []struct {
	T *Token
} {
	var calls []struct {
		T *Token
	}
	mock.lockRegisterToken.RLock()
	calls = mock.calls.RegisterToken
	mock.lockRegisterToken.RUnlock()
	return calls
}

// RevokeCode calls RevokeCodeFunc.
func (mock *OAuth2RepositoryMock) RevokeCode(code string) error {
	if mock.RevokeCodeFunc == nil {
		panic("OAuth2RepositoryMock.RevokeCodeFunc: method is nil but OAuth2Repository.RevokeCode was just called")
	}
	callInfo := struct {
		Code string
	}{
		Code: code,
	}
	mock.lockRevokeCode.Lock()
	mock.calls.RevokeCode = append(mock.calls.RevokeCode, callInfo)
	mock.lockRevokeCode.Unlock()
	return mock.RevokeCodeFunc(code)
}

// RevokeCodeCalls gets all the calls that were made to RevokeCode.
// Check the length with:
//
//	len(mockedOAuth2Repository.RevokeCodeCalls())
func (mock *OAuth2RepositoryMock) RevokeCodeCalls() []struct {
	Code string
} {
	var calls []struct {
		Code string
	}
	mock.lockRevokeCode.RLock()
	calls = mock.calls.RevokeCode
	mock.lockRevokeCode.RUnlock()
	return calls
}

// RevokeRefreshToken calls RevokeRefreshTokenFunc.
func (mock *OAuth2RepositoryMock) RevokeRefreshToken(refreshToken string) error {
	if mock.RevokeRefreshTokenFunc == nil {
		panic("OAuth2RepositoryMock.RevokeRefreshTokenFunc: method is nil but OAuth2Repository.RevokeRefreshToken was just called")
	}
	callInfo := struct {
		RefreshToken string
	}{
		RefreshToken: refreshToken,
	}
	mock.lockRevokeRefreshToken.Lock()
	mock.calls.RevokeRefreshToken = append(mock.calls.RevokeRefreshToken, callInfo)
	mock.lockRevokeRefreshToken.Unlock()
	return mock.RevokeRefreshTokenFunc(refreshToken)
}

// RevokeRefreshTokenCalls gets all the calls that were made to RevokeRefreshToken.
// Check the length with:
//
//	len(mockedOAuth2Repository.RevokeRefreshTokenCalls())
func (mock *OAuth2RepositoryMock) RevokeRefreshTokenCalls() []struct {
	RefreshToken string
} {
	var calls []struct {
		RefreshToken string
	}
	mock.lockRevokeRefreshToken.RLock()
	calls = mock.calls.RevokeRefreshToken
	mock.lockRevokeRefreshToken.RUnlock()
	return calls
}

// RevokeToken calls RevokeTokenFunc.
func (mock *OAuth2RepositoryMock) RevokeToken(accessToken string) error {
	if mock.RevokeTokenFunc == nil {
		panic("OAuth2RepositoryMock.RevokeTokenFunc: method is nil but OAuth2Repository.RevokeToken was just called")
	}
	callInfo := struct {
		AccessToken string
	}{
		AccessToken: accessToken,
	}
	mock.lockRevokeToken.Lock()
	mock.calls.RevokeToken = append(mock.calls.RevokeToken, callInfo)
	mock.lockRevokeToken.Unlock()
	return mock.RevokeTokenFunc(accessToken)
}

// RevokeTokenCalls gets all the calls that were made to RevokeToken.
// Check the length with:
//
//	len(mockedOAuth2Repository.RevokeTokenCalls())
func (mock *OAuth2RepositoryMock) RevokeTokenCalls() []struct {
	AccessToken string
} {
	var calls []struct {
		AccessToken string
	}
	mock.lockRevokeToken.RLock()
	calls = mock.calls.RevokeToken
	mock.lockRevokeToken.RUnlock()
	return calls
}
