// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package session

import (
	"github.com/gin-gonic/gin"
	"sync"
)

// Ensure, that SessionManagerMock does implement SessionManager.
// If this is not the case, regenerate this file with moq.
var _ SessionManager = &SessionManagerMock{}

// SessionManagerMock is a mock implementation of SessionManager.
//
//	func TestSomethingThatUsesSessionManager(t *testing.T) {
//
//		// make and configure a mocked SessionManager
//		mockedSessionManager := &SessionManagerMock{
//			NewSessionFunc: func(c *gin.Context) SessionClient {
//				panic("mock out the NewSession method")
//			},
//		}
//
//		// use mockedSessionManager in code that requires SessionManager
//		// and then make assertions.
//
//	}
type SessionManagerMock struct {
	// NewSessionFunc mocks the NewSession method.
	NewSessionFunc func(c *gin.Context) SessionClient

	// calls tracks calls to the methods.
	calls struct {
		// NewSession holds details about calls to the NewSession method.
		NewSession []struct {
			// C is the c argument value.
			C *gin.Context
		}
	}
	lockNewSession sync.RWMutex
}

// NewSession calls NewSessionFunc.
func (mock *SessionManagerMock) NewSession(c *gin.Context) SessionClient {
	if mock.NewSessionFunc == nil {
		panic("SessionManagerMock.NewSessionFunc: method is nil but SessionManager.NewSession was just called")
	}
	callInfo := struct {
		C *gin.Context
	}{
		C: c,
	}
	mock.lockNewSession.Lock()
	mock.calls.NewSession = append(mock.calls.NewSession, callInfo)
	mock.lockNewSession.Unlock()
	return mock.NewSessionFunc(c)
}

// NewSessionCalls gets all the calls that were made to NewSession.
// Check the length with:
//
//	len(mockedSessionManager.NewSessionCalls())
func (mock *SessionManagerMock) NewSessionCalls() []struct {
	C *gin.Context
} {
	var calls []struct {
		C *gin.Context
	}
	mock.lockNewSession.RLock()
	calls = mock.calls.NewSession
	mock.lockNewSession.RUnlock()
	return calls
}
