// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package domain

import (
	"github.com/google/uuid"
	"sync"
)

// Ensure, that UserMock does implement User.
// If this is not the case, regenerate this file with moq.
var _ User = &UserMock{}

// UserMock is a mock implementation of User.
//
//	func TestSomethingThatUsesUser(t *testing.T) {
//
//		// make and configure a mocked User
//		mockedUser := &UserMock{
//			GetIDFunc: func() uuid.UUID {
//				panic("mock out the GetID method")
//			},
//			IsNotFoundFunc: func() bool {
//				panic("mock out the IsNotFound method")
//			},
//			IsPasswordMatchFunc: func(password string) bool {
//				panic("mock out the IsPasswordMatch method")
//			},
//		}
//
//		// use mockedUser in code that requires User
//		// and then make assertions.
//
//	}
type UserMock struct {
	// GetIDFunc mocks the GetID method.
	GetIDFunc func() uuid.UUID

	// IsNotFoundFunc mocks the IsNotFound method.
	IsNotFoundFunc func() bool

	// IsPasswordMatchFunc mocks the IsPasswordMatch method.
	IsPasswordMatchFunc func(password string) bool

	// calls tracks calls to the methods.
	calls struct {
		// GetID holds details about calls to the GetID method.
		GetID []struct {
		}
		// IsNotFound holds details about calls to the IsNotFound method.
		IsNotFound []struct {
		}
		// IsPasswordMatch holds details about calls to the IsPasswordMatch method.
		IsPasswordMatch []struct {
			// Password is the password argument value.
			Password string
		}
	}
	lockGetID           sync.RWMutex
	lockIsNotFound      sync.RWMutex
	lockIsPasswordMatch sync.RWMutex
}

// GetID calls GetIDFunc.
func (mock *UserMock) GetID() uuid.UUID {
	if mock.GetIDFunc == nil {
		panic("UserMock.GetIDFunc: method is nil but User.GetID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetID.Lock()
	mock.calls.GetID = append(mock.calls.GetID, callInfo)
	mock.lockGetID.Unlock()
	return mock.GetIDFunc()
}

// GetIDCalls gets all the calls that were made to GetID.
// Check the length with:
//
//	len(mockedUser.GetIDCalls())
func (mock *UserMock) GetIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetID.RLock()
	calls = mock.calls.GetID
	mock.lockGetID.RUnlock()
	return calls
}

// IsNotFound calls IsNotFoundFunc.
func (mock *UserMock) IsNotFound() bool {
	if mock.IsNotFoundFunc == nil {
		panic("UserMock.IsNotFoundFunc: method is nil but User.IsNotFound was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsNotFound.Lock()
	mock.calls.IsNotFound = append(mock.calls.IsNotFound, callInfo)
	mock.lockIsNotFound.Unlock()
	return mock.IsNotFoundFunc()
}

// IsNotFoundCalls gets all the calls that were made to IsNotFound.
// Check the length with:
//
//	len(mockedUser.IsNotFoundCalls())
func (mock *UserMock) IsNotFoundCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsNotFound.RLock()
	calls = mock.calls.IsNotFound
	mock.lockIsNotFound.RUnlock()
	return calls
}

// IsPasswordMatch calls IsPasswordMatchFunc.
func (mock *UserMock) IsPasswordMatch(password string) bool {
	if mock.IsPasswordMatchFunc == nil {
		panic("UserMock.IsPasswordMatchFunc: method is nil but User.IsPasswordMatch was just called")
	}
	callInfo := struct {
		Password string
	}{
		Password: password,
	}
	mock.lockIsPasswordMatch.Lock()
	mock.calls.IsPasswordMatch = append(mock.calls.IsPasswordMatch, callInfo)
	mock.lockIsPasswordMatch.Unlock()
	return mock.IsPasswordMatchFunc(password)
}

// IsPasswordMatchCalls gets all the calls that were made to IsPasswordMatch.
// Check the length with:
//
//	len(mockedUser.IsPasswordMatchCalls())
func (mock *UserMock) IsPasswordMatchCalls() []struct {
	Password string
} {
	var calls []struct {
		Password string
	}
	mock.lockIsPasswordMatch.RLock()
	calls = mock.calls.IsPasswordMatch
	mock.lockIsPasswordMatch.RUnlock()
	return calls
}
